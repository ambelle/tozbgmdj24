<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TOZ BGM Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b0b12;
      color: #f5f5f5;
      margin: 0;
      padding: 20px;
      text-align: center;
    }

    h1 {
      margin-bottom: 4px;
    }

    p.sub {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 0.95rem;
      color: #c0c0d0;
    }

    #container {
      max-width: 480px;
      margin: 0 auto;
      background: #161623;
      padding: 16px 18px 20px;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.45);
      text-align: left;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    button {
      flex: 1;
      min-width: 120px;
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.95rem;
      background: #3f8cff;
      color: white;
    }

    button.secondary {
      background: #444b5f;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .status-line {
      font-size: 0.9rem;
      margin-bottom: 4px;
    }

    #status {
      font-weight: 600;
      margin-bottom: 6px;
    }

    #status.idle {
      color: #c0c0d0;
    }
    #status.listening {
      color: #5bd75b;
    }
    #status.error {
      color: #ff6b6b;
    }

    #resultBox {
      margin-top: 10px;
      padding: 10px;
      border-radius: 8px;
      background: #11111a;
      font-size: 0.92rem;
      min-height: 3.5em;
      line-height: 1.4;
    }

    .result-label {
      font-weight: 600;
      margin-right: 4px;
    }

    #matchName {
      font-weight: 700;
      color: #5bd75b;
    }

    #backendUrlInfo {
      font-size: 0.8rem;
      color: #8b8ba0;
      margin-top: 10px;
    }

    .hint {
      font-size: 0.8rem;
      color: #a0a0b8;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <h1>TOZ BGM Scanner</h1>
  <p class="sub">Hold your phone near the game BGM and tap “Start scanning”.</p>

  <div id="container">
    <div class="btn-row">
      <button id="startBtn">Start scanning</button>
      <button id="stopBtn" class="secondary" disabled>Stop</button>
    </div>

    <div class="status-line">
      <span id="status" class="idle">Idle. Not recording.</span>
    </div>
    <div class="status-line">
      <span id="detail">Waiting to start…</span>
    </div>

    <div id="resultBox">
      <div><span class="result-label">Result:</span><span id="resultText">No scan yet.</span></div>
      <div id="matchLine" style="display:none; margin-top:4px;">
        <span class="result-label">Match:</span><span id="matchName"></span>
      </div>
    </div>

    <div id="backendUrlInfo">
      Backend: <code>https://toz-bgm-backend.onrender.com/match</code>
    </div>
    <div class="hint">
      Tip: Use in a quiet room and keep the phone mic close to your speakers.
    </div>
  </div>

  <script>
    // === CONFIG ===
    const BACKEND_URL = "https://toz-bgm-backend.onrender.com/match";
    const CHUNK_SECONDS = 1.5;  // length of audio chunk to send
    // =============

    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let processorNode = null;

    let recording = false;
    let buffer = new Float32Array(0);
    let chunkSamples = 0;

    const startBtn   = document.getElementById("startBtn");
    const stopBtn    = document.getElementById("stopBtn");
    const statusEl   = document.getElementById("status");
    const detailEl   = document.getElementById("detail");
    const resultText = document.getElementById("resultText");
    const matchLine  = document.getElementById("matchLine");
    const matchNameEl = document.getElementById("matchName");

    function setStatus(mode, text, detail) {
      statusEl.className = mode;
      statusEl.textContent = text;
      if (detail !== undefined) {
        detailEl.textContent = detail;
      }
    }

    function resetResult() {
      resultText.textContent = "No scan yet.";
      matchLine.style.display = "none";
      matchNameEl.textContent = "";
    }

    async function startRecording() {
      if (recording) return;

      resetResult();

      try {
        // iOS Safari is picky: create AudioContext inside user gesture
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // ask for mic
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

        sourceNode = audioCtx.createMediaStreamSource(mediaStream);

        // ScriptProcessorNode is deprecated but widely supported (incl. Safari)
        const bufferSize = 4096;
        processorNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);

        buffer = new Float32Array(0);
        chunkSamples = Math.floor(audioCtx.sampleRate * CHUNK_SECONDS);

        processorNode.onaudioprocess = (event) => {
          if (!recording) return;

          const input = event.inputBuffer.getChannelData(0);
          appendToBuffer(input);

          while (buffer.length >= chunkSamples) {
            const chunk = buffer.slice(0, chunkSamples);
            buffer = buffer.slice(chunkSamples);
            handleChunk(chunk, audioCtx.sampleRate);
          }
        };

        sourceNode.connect(processorNode);
        processorNode.connect(audioCtx.destination);

        recording = true;
        startBtn.disabled = true;
        stopBtn.disabled  = false;
        setStatus("listening", "Listening…", "Sending ~1.5s chunks to the server.");

      } catch (err) {
        console.error(err);
        setStatus("error", "Error: cannot access microphone.", "Please allow mic access in your browser settings.");
      }
    }

    function stopRecording() {
      recording = false;
      startBtn.disabled = false;
      stopBtn.disabled  = true;

      if (processorNode) {
        processorNode.disconnect();
        processorNode.onaudioprocess = null;
        processorNode = null;
      }
      if (sourceNode) {
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
      if (audioCtx) {
        // optional: keep it alive; for now just close
        audioCtx.close();
        audioCtx = null;
      }

      buffer = new Float32Array(0);
      setStatus("idle", "Idle. Not recording.", "Tap “Start scanning” to try again.");
    }

    function appendToBuffer(newData) {
      const tmp = new Float32Array(buffer.length + newData.length);
      tmp.set(buffer, 0);
      tmp.set(newData, buffer.length);
      buffer = tmp;
    }

    async function handleChunk(samples, sampleRate) {
      try {
        const wavBlob = encodeWAV(samples, sampleRate);
        await sendChunkToBackend(wavBlob);
      } catch (err) {
        console.error("Error handling chunk:", err);
        setStatus("error", "Error while processing audio.", "You can stop and start again.");
      }
    }

    async function sendChunkToBackend(wavBlob) {
      const formData = new FormData();
      formData.append("audio", wavBlob, "chunk.wav");

      try {
        const resp = await fetch(BACKEND_URL, {
          method: "POST",
          body: formData,
        });

        if (!resp.ok) {
          console.warn("Backend returned non-200:", resp.status);
          resultText.textContent = "Server responded with " + resp.status + ". Still listening…";
          return;
        }

        const data = await resp.json();
        console.log("Backend response:", data);

        if (data.status === "match") {
          resultText.textContent = "Match found!";
          matchNameEl.textContent = data.name || "(unknown map)";
          matchLine.style.display = "block";
          setStatus("listening", "Listening (match locked).", "You can stop now or keep scanning.");
          // Optionally: stopRecording();  // uncomment if you want auto-stop when matched
        } else if (data.status === "no_match") {
          resultText.textContent = "No clear match yet, still listening…";
        } else if (data.status === "error") {
          resultText.textContent = "Server error: " + (data.message || "unknown.");
          setStatus("error", "Error from server.", "Try again in a moment.");
        } else {
          resultText.textContent = "Unknown response from server.";
        }
      } catch (err) {
        console.error("Network / parse error:", err);
        resultText.textContent = "Network error. Still listening…";
      }
    }

    // Encode Float32 PCM -> 16-bit WAV Blob
    function encodeWAV(samples, sampleRate) {
      const numChannels = 1;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = samples.length * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      /* RIFF header */
      writeString(view, 0, "RIFF");
      view.setUint32(4, 36 + dataSize, true); // file size minus 8
      writeString(view, 8, "WAVE");
      /* fmt chunk */
      writeString(view, 12, "fmt ");
      view.setUint32(16, 16, true);          // PCM chunk size
      view.setUint16(20, 1, true);           // PCM format
      view.setUint16(22, numChannels, true); // channels
      view.setUint32(24, sampleRate, true);  // sample rate
      view.setUint32(28, byteRate, true);    // byte rate
      view.setUint16(32, blockAlign, true);  // block align
      view.setUint16(34, 16, true);          // bits per sample
      /* data chunk */
      writeString(view, 36, "data");
      view.setUint32(40, dataSize, true);

      floatTo16BitPCM(view, 44, samples);

      return new Blob([buffer], { type: "audio/wav" });
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function floatTo16BitPCM(view, offset, input) {
      for (let i = 0; i < input.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, input[i]));
        // convert from [-1, 1] to signed 16-bit
        s = s < 0 ? s * 0x8000 : s * 0x7FFF;
        view.setInt16(offset, s, true);
      }
    }

    // Hook up buttons
    startBtn.addEventListener("click", () => {
      startRecording();
    });

    stopBtn.addEventListener("click", () => {
      stopRecording();
    });
  </script>
</body>
</html>
