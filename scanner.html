<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TOZ BGM Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1020;
      color: #f5f5f5;
      margin: 0;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    h1 {
      font-size: 1.4rem;
      margin: 0;
    }

    .card {
      background: #151a30;
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
    }

    button {
      background: #4f46e5;
      border: none;
      border-radius: 999px;
      padding: 0.8rem 1.6rem;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: #1f2937;
      border-radius: 999px;
      padding: 0.25rem 0.8rem;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .status {
      font-size: 0.95rem;
      color: #d1d5db;
      min-height: 1.2rem;
    }

    .result-title {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-bottom: 0.25rem;
    }

    .result-main {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .result-sub {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-top: 0.2rem;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #10b981;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.35); opacity: 0.4; }
      100% { transform: scale(1); opacity: 1; }
    }

    .dot.red { background: #ef4444; animation: none; }
  </style>
</head>
<body>
  <div class="card">
    <h1>üéß TOZ BGM Scanner</h1>
    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #9ca3af;">
      Hold your phone near the game and tap <strong>Start Listening</strong>.
      Works on desktop and mobile (iPhone Safari included).
    </p>

    <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.75rem;">
      <button id="recordBtn">
        <span id="recordIcon">‚ñ∂Ô∏è</span>
        <span id="recordLabel">Start Listening</span>
      </button>

      <div class="pill">
        <div id="recordDot" class="dot red"></div>
        <span id="recordStateLabel">Idle</span>
      </div>
    </div>

    <div style="margin-top: 1.2rem;" class="status" id="status">
      Not recording.
    </div>

    <div style="margin-top: 1.4rem;">
      <div class="result-title">Result</div>
      <div class="result-main" id="resultMain">‚Äî</div>
      <div class="result-sub" id="resultSub"></div>
    </div>
  </div>

  <script>
    // üîó PUT YOUR BACKEND URL HERE (Render service URL, NO trailing slash)
    const API_BASE = "https://toz-bgm-backend.onrender.com"; // <- CHANGE THIS

    let audioContext = null;
    let processor = null;
    let mediaStream = null;
    let isRecording = false;

    // We store chunks of Float32Array from onaudioprocess
    const floatChunks = [];
    let sendTimer = null;

    const recordBtn = document.getElementById("recordBtn");
    const recordIcon = document.getElementById("recordIcon");
    const recordLabel = document.getElementById("recordLabel");
    const recordDot = document.getElementById("recordDot");
    const recordStateLabel = document.getElementById("recordStateLabel");
    const statusEl = document.getElementById("status");
    const resultMain = document.getElementById("resultMain");
    const resultSub = document.getElementById("resultSub");

    function setStatus(msg) {
      statusEl.textContent = msg;
      console.log("[Scanner]", msg);
    }

    function setRecordingUI(active) {
      if (active) {
        recordIcon.textContent = "‚èπÔ∏è";
        recordLabel.textContent = "Stop Listening";
        recordDot.classList.remove("red");
        recordStateLabel.textContent = "Listening‚Ä¶";
      } else {
        recordIcon.textContent = "‚ñ∂Ô∏è";
        recordLabel.textContent = "Start Listening";
        recordDot.classList.add("red");
        recordStateLabel.textContent = "Idle";
      }
    }

    function concatFloat32(chunks) {
      let total = 0;
      for (const c of chunks) total += c.length;
      const out = new Float32Array(total);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.length;
      }
      return out;
    }

    function encodeWav(samples, sampleRate) {
      const numChannels = 1;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = samples.length * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      function writeString(offset, str) {
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
      }

      let offset = 0;
      writeString(0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeString(8, "WAVE");
      writeString(12, "fmt ");
      view.setUint32(16, 16, true);      // fmt chunk size
      view.setUint16(20, 1, true);       // audio format = PCM
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);      // bits per sample
      writeString(36, "data");
      view.setUint32(40, dataSize, true);

      // PCM samples
      let idx = 44;
      for (let i = 0; i < samples.length; i++, idx += 2) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        const int16 = s < 0 ? s * 0x8000 : s * 0x7fff;
        view.setInt16(idx, int16, true);
      }

      return new Blob([buffer], { type: "audio/wav" });
    }

    async function sendChunkToBackend() {
      if (!isRecording || !audioContext) return;
      if (floatChunks.length === 0) return;

      const all = concatFloat32(floatChunks);
      const sampleRate = audioContext.sampleRate;

      // We only need ~1.5s of recent audio for matching
      const windowSec = 1.5;
      const windowSamples = Math.floor(windowSec * sampleRate);
      if (all.length < windowSamples) {
        setStatus("Listening‚Ä¶ (capturing enough audio)");
        return;
      }

      const slice = all.slice(all.length - windowSamples);
      const wavBlob = encodeWav(slice, sampleRate);

      try {
        setStatus("Sending chunk to server‚Ä¶");

        const resp = await fetch(`${API_BASE}/match`, {
          method: "POST",
          headers: {
            "Content-Type": "audio/wav",
            "Accept": "application/json",
          },
          body: wavBlob,
        });

        let data = null;
        try {
          data = await resp.json();
        } catch (e) {
          console.warn("Failed to parse JSON:", e);
        }

        if (!resp.ok) {
          console.warn("/match error:", resp.status, data);
          setStatus("Server error while matching.");
          return;
        }

        if (!data || !data.ok) {
          setStatus("No valid response from server.");
          return;
        }

        if (data.match && data.confidence != null) {
          const confPct = Math.round(data.confidence * 100);
          resultMain.textContent = data.match;
          resultSub.textContent = `Confidence: ${confPct}% (threshold ${(data.threshold * 100).toFixed(0)}%)`;
          setStatus("Match found!");

          if (data.is_confident) {
            // Stop recording if it's confident enough
            stopRecording();
          } else {
            setStatus("Possible match, still listening for higher confidence‚Ä¶");
          }
        } else {
          setStatus("No match yet, still listening‚Ä¶");
        }
      } catch (err) {
        console.error("Network / match error:", err);
        setStatus("Network error while calling /match.");
      }
    }

    async function startRecording() {
      if (isRecording) return;

      try {
        // Create / resume AudioContext (Safari needs resume on user gesture)
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioContext.state === "suspended") {
          await audioContext.resume();
        }

        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          },
        });

        const source = audioContext.createMediaStreamSource(mediaStream);
        const bufferSize = 4096;
        processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

        processor.onaudioprocess = (e) => {
          if (!isRecording) return;
          const input = e.inputBuffer.getChannelData(0);
          // copy the buffer so it's not overwritten
          floatChunks.push(new Float32Array(input));
        };

        source.connect(processor);
        processor.connect(audioContext.destination);

        // clear previous session
        floatChunks.length = 0;
        resultMain.textContent = "‚Äî";
        resultSub.textContent = "";

        isRecording = true;
        setRecordingUI(true);
        setStatus("Listening‚Ä¶ hold the phone near the game audio.");

        // Send chunk every 1.5s
        if (sendTimer) clearInterval(sendTimer);
        sendTimer = setInterval(sendChunkToBackend, 1500);
      } catch (err) {
        console.error("startRecording error:", err);
        setStatus("Failed to start recording. Please allow microphone access.");
      }
    }

    function stopRecording() {
      if (!isRecording) return;
      isRecording = false;
      setRecordingUI(false);

      if (sendTimer) {
        clearInterval(sendTimer);
        sendTimer = null;
      }

      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
        processor = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach((t) => t.stop());
        mediaStream = null;
      }

      setStatus("Stopped. Tap Start Listening to scan again.");
    }

    recordBtn.addEventListener("click", () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });

    // Small hint if getUserMedia is not available
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setStatus("Your browser does not support microphone access.");
      recordBtn.disabled = true;
    }
  </script>
</body>
</html>
