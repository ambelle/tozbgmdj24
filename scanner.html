<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Maple BGM Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #e5e7eb;
      margin: 0;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      max-width: 800px;
      box-sizing: border-box;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0;
      color: #f97316;
      text-align: center;
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937, #020617);
      border-radius: 1rem;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: center;
      margin-bottom: 0.75rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.2rem;
      font-size: 0.95rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-weight: 500;
      transition: transform 0.12s ease, box-shadow 0.12s ease,
        background 0.12s ease, opacity 0.12s ease;
      white-space: nowrap;
    }

    button.primary {
      background: linear-gradient(135deg, #f97316, #facc15);
      color: #0b1120;
      box-shadow: 0 12px 30px rgba(249, 115, 22, 0.45);
    }

    button.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 40px rgba(249, 115, 22, 0.55);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    button.secondary:hover {
      background: rgba(15, 23, 42, 1);
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    .status-line {
      font-size: 0.9rem;
      color: #e5e7eb;
      margin-top: 0.25rem;
      text-align: center;
      min-height: 1.4em;
    }

    .status-line span.label {
      color: #9ca3af;
    }

    .status-line span.value {
      font-weight: 500;
    }

    .match-box {
      margin-top: 0.75rem;
      padding: 0.85rem 0.9rem;
      border-radius: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .match-title {
      font-weight: 600;
      color: #f97316;
      margin-bottom: 0.25rem;
    }

    .match-line {
      margin: 0.12rem 0;
    }

    .match-label {
      color: #9ca3af;
    }

    .match-value {
      color: #e5e7eb;
      font-weight: 500;
    }

    .chip-row {
      margin-top: 0.35rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .chip {
      font-size: 0.75rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.55);
      color: #e5e7eb;
    }

    .chip.green {
      border-color: #22c55e;
      color: #bbf7d0;
    }

    .chip.red {
      border-color: #ef4444;
      color: #fecaca;
    }

    .chip.yellow {
      border-color: #eab308;
      color: #fef3c7;
    }

    @media (max-width: 480px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 1.4rem;
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .card {
        padding: 1rem 0.9rem;
      }
    }
  </style>
</head>
<body>
  <h1>MapleStory BGM Scanner</h1>

  <div class="card">
    <div class="controls">
      <button id="startBtn" class="primary">
        ▶️ Start Scanning
      </button>
      <button id="stopBtn" class="secondary" disabled>
        ⏹ Stop
      </button>
    </div>

    <div class="status-line">
      <span class="label">Scanner:</span>
      <span id="statusText" class="value">Idle</span>
    </div>
    <div class="status-line">
      <span class="label">Chunks sent:</span>
      <span id="chunksText" class="value">0</span>
    </div>

    <div id="matchBox" class="match-box" style="display:none;">
      <div class="match-title" id="matchTitle">Result</div>
      <div class="match-line">
        <span class="match-label">Song:</span>
        <span class="match-value" id="matchName">—</span>
      </div>
      <div class="match-line">
        <span class="match-label">Location:</span>
        <span class="match-value" id="matchLocation">—</span>
      </div>
      <div class="match-line">
        <span class="match-label">Score:</span>
        <span class="match-value" id="matchScore">—</span>
      </div>
      <div class="chip-row">
        <div class="chip yellow" id="hintChip">
          Listening for Maple BGM...
        </div>
        <div class="chip red" id="browserChip" style="display:none;">
          If it never matches, try Chrome / Edge desktop.
        </div>
        <div class="chip green" id="stopHintChip" style="display:none;">
          Scanner stops automatically once it finds a strong match.
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_URL = "https://toz-bgm-backend.onrender.com/match";

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusText = document.getElementById("statusText");
    const chunksText = document.getElementById("chunksText");

    const matchBox = document.getElementById("matchBox");
    const matchTitle = document.getElementById("matchTitle");
    const matchName = document.getElementById("matchName");
    const matchLocation = document.getElementById("matchLocation");
    const matchScore = document.getElementById("matchScore");
    const hintChip = document.getElementById("hintChip");
    const browserChip = document.getElementById("browserChip");
    const stopHintChip = document.getElementById("stopHintChip");

    let audioContext = null;
    let processor = null;
    let micStream = null;
    let isRecording = false;
    let chunksSent = 0;
    let bestMatch = null;
    let noMatchCount = 0;
    let abortController = null;
    let chunkBuffer = [];
    let chunkSampleRate = 44100;

    const CHUNK_SECONDS = 1.5;
    const MAX_NO_MATCH_CHUNKS = 12;
    const AUTO_STOP_SCORE = 0.80;

    function setStatus(text) {
      statusText.textContent = text;
    }

    function resetUI() {
      chunksSent = 0;
      noMatchCount = 0;
      bestMatch = null;
      chunksText.textContent = "0";
      matchBox.style.display = "none";
      matchName.textContent = "—";
      matchLocation.textContent = "—";
      matchScore.textContent = "—";
      matchTitle.textContent = "Result";
      hintChip.textContent = "Listening for Maple BGM...";
      hintChip.className = "chip yellow";
      browserChip.style.display = "none";
      stopHintChip.style.display = "none";
    }

    function showMatch(match) {
      matchBox.style.display = "block";
      if (!match) {
        matchTitle.textContent = "No match found yet";
        matchName.textContent = "—";
        matchLocation.textContent = "—";
        matchScore.textContent = "—";
        hintChip.textContent = "Keep the BGM clear and close to the mic.";
        hintChip.className = "chip yellow";
        return;
      }
      matchTitle.textContent = "Best guess so far";
      matchName.textContent = match.name || "Unknown";
      matchLocation.textContent = match.location || "Unknown";
      matchScore.textContent = match.score != null ? match.score.toFixed(2) : "—";
      hintChip.textContent = "If this looks right, you can stop.";
      hintChip.className = "chip green";
      stopHintChip.style.display = "inline-block";
    }

    function showBrowserWarning(msg) {
      matchBox.style.display = "block";
      matchTitle.textContent = "Result";
      matchName.textContent = msg || "Recording works, but this browser's audio format is not supported.";
      matchLocation.textContent = "Try desktop Chrome / Edge for best results.";
      matchScore.textContent = "—";
      hintChip.textContent = "Mobile Safari often uses non-WAV formats.";
      hintChip.className = "chip red";
      browserChip.style.display = "inline-block";
    }

    // Classic WAV encoder (mono, 16-bit PCM)
    function encodeWAV(samples, sampleRate) {
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      let offset = 0;

      writeString(view, offset, "RIFF"); offset += 4;
      view.setUint32(offset, 36 + samples.length * 2, true); offset += 4;
      writeString(view, offset, "WAVE"); offset += 4;
      writeString(view, offset, "fmt "); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;      // PCM chunk size
      view.setUint16(offset, 1, true); offset += 2;       // audio format (PCM)
      view.setUint16(offset, 1, true); offset += 2;       // channels (mono)
      view.setUint32(offset, sampleRate, true); offset += 4;
      view.setUint32(offset, sampleRate * 2, true); offset += 4; // byte rate
      view.setUint16(offset, 2, true); offset += 2;       // block align
      view.setUint16(offset, 16, true); offset += 2;      // bits per sample
      writeString(view, offset, "data"); offset += 4;
      view.setUint32(offset, samples.length * 2, true); offset += 4;

      let idx = 44;
      for (let i = 0; i < samples.length; i++, idx += 2) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        // Convert float [-1,1] to 16-bit PCM
        view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }

      return new Blob([buffer], { type: "audio/wav" });
    }

    async function sendChunk(float32Samples) {
      if (!float32Samples || float32Samples.length === 0) return;

      const wavBlob = encodeWAV(float32Samples, chunkSampleRate);
      const formData = new FormData();
      formData.append("audio", wavBlob, "chunk.wav");

      try {
        abortController = new AbortController();
        const resp = await fetch(API_URL, {
          method: "POST",
          body: formData,
          signal: abortController.signal
        });

        const data = await resp.json();
        chunksSent++;
        chunksText.textContent = String(chunksSent);

        if (!resp.ok) {
          console.error("Backend error:", data);
          if (data && data.error && data.error.includes("Format")) {
            showBrowserWarning("Server cannot decode this browser's audio chunks.");
            setStatus("Browser format not supported by server");
            stopRecording(false);
          } else {
            setStatus("Server error while matching.");
          }
          return;
        }

        if (data.browser_note) {
          // Optional: if backend returns a browser_note
          browserChip.style.display = "inline-block";
          browserChip.textContent = data.browser_note;
        }

        if (data.best_match) {
          bestMatch = data.best_match;
          showMatch(bestMatch);

          if (bestMatch.score >= AUTO_STOP_SCORE) {
            setStatus("Strong match found. Stopping.");
            stopRecording(false);
            return;
          }
        } else {
          noMatchCount++;
          showMatch(null);
          if (noMatchCount >= MAX_NO_MATCH_CHUNKS) {
            setStatus("No match. Try moving closer or using clearer audio.");
            stopRecording(false);
            return;
          }
        }

      } catch (err) {
        if (err.name === "AbortError") {
          console.log("Fetch aborted (stop pressed).");
          return;
        }
        console.error("Error sending chunk:", err);
        setStatus("Network error while sending audio.");
      }
    }

    function onAudioProcess(e) {
      if (!isRecording) return;
      const input = e.inputBuffer.getChannelData(0); // mono
      chunkBuffer.push(new Float32Array(input));

      const totalLength = chunkBuffer.reduce((acc, cur) => acc + cur.length, 0);
      if (totalLength >= chunkSampleRate * CHUNK_SECONDS) {
        const merged = new Float32Array(totalLength);
        let offset = 0;
        for (const buf of chunkBuffer) {
          merged.set(buf, offset);
          offset += buf.length;
        }
        chunkBuffer = [];

        sendChunk(merged);
      }
    }

    async function startRecording() {
      if (isRecording) return;

      resetUI();
      setStatus("Requesting microphone...");

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        chunkSampleRate = audioContext.sampleRate || 44100;

        micStream = audioContext.createMediaStreamSource(stream);
        processor = audioContext.createScriptProcessor(4096, 1, 1);
        processor.onaudioprocess = onAudioProcess;

        micStream.connect(processor);
        processor.connect(audioContext.destination);

        isRecording = true;
        setStatus(`Listening… sampleRate=${chunkSampleRate} Hz`);
        startBtn.disabled = true;
        stopBtn.disabled = false;
        hintChip.textContent = "Hold your phone near the Maple BGM source.";
        browserChip.style.display = "none";
      } catch (err) {
        console.error("Mic error:", err);
        setStatus("Could not access microphone.");
        showBrowserWarning("Microphone access failed. Check browser permissions.");
      }
    }

    function stopRecording(userInitiated = true) {
      if (!isRecording && !audioContext) return;

      isRecording = false;

      if (abortController) {
        abortController.abort();
      }

      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
        processor = null;
      }
      if (micStream) {
        micStream.disconnect();
        micStream = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      chunkBuffer = [];

      startBtn.disabled = false;
      stopBtn.disabled = true;

      if (userInitiated) {
        setStatus("Stopped by user.");
      } else {
        if (bestMatch) {
          setStatus("Stopped after match.");
        } else {
          setStatus("Stopped.");
        }
      }
    }

    startBtn.addEventListener("click", () => {
      startRecording();
    });

    stopBtn.addEventListener("click", () => {
      stopRecording(true);
    });

    window.addEventListener("pagehide", () => {
      stopRecording(false);
    });
    window.addEventListener("beforeunload", () => {
      stopRecording(false);
    });
  </script>
</body>
</html>
